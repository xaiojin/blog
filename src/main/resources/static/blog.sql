/*
SQLyog Enterprise v13.1.1 (64 bit)
MySQL - 5.5.53 : Database - blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `blog`;

/*Table structure for table `hibernate_sequence` */

DROP TABLE IF EXISTS `hibernate_sequence`;

CREATE TABLE `hibernate_sequence` (
  `next_val` bigint(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `hibernate_sequence` */

insert  into `hibernate_sequence`(`next_val`) values 
(86),
(86),
(86),
(86),
(86);

/*Table structure for table `t_blog` */

DROP TABLE IF EXISTS `t_blog`;

CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL,
  `appreciation` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `content` longtext,
  `create_time` datetime DEFAULT NULL,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `views` int(11) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`),
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`),
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`),
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_blog` */

insert  into `t_blog`(`id`,`appreciation`,`commentabled`,`content`,`create_time`,`first_picture`,`flag`,`published`,`recommend`,`share_statement`,`title`,`update_time`,`views`,`type_id`,`user_id`,`description`) values 
(21,'','','1.为什么要使用Hibernate开发你的项目呢？Hibernate的开发流程是怎么样的？\r\n为什么要使用\r\n\r\n①.对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 \r\n\r\n②.Hibernate 是一个基于JDBC的主流持久化框架，是一个优秀的ORM 实现。他很大程度的简化DAO层的编码工作 \r\n\r\n③.hibernate 的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。\r\n\r\n开发流程\r\n\r\n \r\n\r\n2.什么是延迟加载？\r\n    延迟加载机制是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才真正执行数据加载操作。在Hibernate中提供了对实体对象的延迟加载以及对集合的延迟加载，另外在Hibernate3中还提供了对属性的延迟加载。\r\n\r\n3.说一下hibernate的缓存机制\r\n\r\n       缓存是介于应用程序和物理数据源之间，其作用是为了降低应用程序对物理数据源访问的频次，从而提高了应用的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据。\r\n\r\n　　缓存的介质一般是内存，所以读写速度很快。但如果缓存中存放的数据量非常大时，也会用硬盘作为缓存介质。缓存的实现不仅仅要考虑存储的介质，还要考虑到管理缓存的并发访问和缓存数据的生命周期。\r\n\r\nA：hibernate一级缓存 \r\n\r\n（1）hibernate支持两个级别的缓存，默认只支持一级缓存； \r\n\r\n（2）每个Session内部自带一个一级缓存； \r\n\r\n（3）某个Session被关闭时，其对应的一级缓存自动清除； \r\n\r\nB：hibernate二级缓存 \r\n\r\n(1) 二级缓存独立于session，默认不开启；\r\n\r\n4.Hibernate的查询方式有哪些？\r\n本地SQL查询、Criteria、Hql\r\n\r\n5.如何优化Hibernate？\r\n1.使用双向一对多关联，不使用单向一对多\r\n\r\n2.灵活使用单向一对多关联\r\n\r\n3.不用一对一，用多对一取代\r\n\r\n4.配置对象缓存，不使用集合缓存\r\n\r\n5.一对多集合使用Bag,多对多集合使用Set\r\n\r\n6. 继承类使用显式多态\r\n\r\n7. 表字段要少，表关联不要怕多，有二级缓存撑腰 \r\n\r\n6.Hibernate中GET和LOAD的区别？\r\n    请注意如果没有匹配的数据库记录，load()方法可能抛出无法恢复的异常(unrecoverable exception)。 如果类的映射使用了代理(proxy)，load()方法会返回一个未初始化的代理，直到你调用该代理的某方法时才会去访问数据库。若你希望在某对象中创建一个指向另一个对象的关联，又不想在从数据库中装载该对象时同时装载相关联的那个对象，那么这种操作方式就用得上的了。 如果为相应类映射关系设置了batch-size， 那么使用这种操作方式允许多个对象被一批装载（因为返回的是代理，无需从数据库中抓取所有对象的数据）。 如果你不确定是否有匹配的行存在，应该使用 get()方法，它会立刻访问数据库，如果没有对应的行，会返回null。\r\n\r\n    session.get 方法， 查询立即执行 ， 返回Customer类对象\r\n\r\n    session.load 方法，默认采用延迟加载数据方式，不会立即查询，返回 Customer类子类对象 （动态生成代理对象）\r\n\r\n* 如果 PO类使用final修饰，load无法创建代理对象，返回目标对象本身 （load效果和 get效果 相同 ） \r\n\r\n7.说说在 hibernate中使用Integer做映射和使用int做映射之间有什么差别？\r\nInteger code和int code的区别: \r\n\r\nInteger是对象.      code=null;   对象可以为空.    \r\n\r\nint 是普通类型,     不可能=null.        \r\n\r\n根据你的数据库code是可以空的,故应该映射成Integer.       \r\n你没理由hbm.xml里写 Integer,类里却写int\r\n\r\n8.SQL和HQL有什么区别？\r\nsql 面向数据库表查询 \r\nhql 面向对象查询 \r\n  \r\nhql：from 后面跟的 类名＋类对象 where 后 用 对象的属性做条件 \r\nsql：from 后面跟的是表名  where 后 用表中字段做条件 \r\n查询 \r\n在Hibernate中使用查询时，一般使用Hql查询语句。 \r\nHQL（Hibernate Query Language），即Hibernate的查询语言跟SQL非常相像。不过HQL与SQL的最根本的区别，就是它是面向对象的。 \r\n  \r\n使用HQL时需要注意以下几点： \r\n1.大小写敏感 \r\n\r\n因为HQL是面向对象的，而对象类的名称和属性都是大小写敏感的，所以HQL是大小写敏感的。\r\n\r\nHQL语句：from Cat as cat where cat.id > 1;与from Cat as cat where cat.ID > 1;是不一样的，这点与SQL不同。\r\n\r\n2.from子句 \r\n\r\nfrom Cat，该句返回Cat对象实例，开发人员也可以给其加上别名，eg. from Cat as cat，对于多表查询的情况，可参考如下：\r\n\r\nfrom Cat as cat, Dog as dog\r\n\r\n其它方面都与SQL类似，在此不再赘述。\r\n\r\n9.Hibernate的分页查询\r\n例如：从数据库中的第20000条数据开始查后面100条记录 \r\n\r\nQuery q = session.createQuery(\"from Cat as c\");;    \r\nq.setMaxResults(100);;    \r\nList l = q.list();; \r\nq.setFirstResult(20000);;  \r\n\r\n10.Hibernate中Java对象的状态以及对应的特征有哪些？\r\n持久化对象的三种状态 \r\n    持久化对象PO和OID \r\nPO=POJO + hbm映射配置 \r\n    编写规则 \r\n\r\n①必须提供无参数public构造器\r\n②所有属性private，提供public的getter和setter方法\r\n③必须提供标识属性，与数据表中主键对应，例如Customer类 id属性\r\n④PO类属性应尽量使用基本数据类型的包装类型(区分空值)  例如int---Integer  long---Long\r\n⑤不要用final修饰（将无法生成代理对象进行优化）\r\nOID 指与数据表中主键对应 PO类中属性，例如 Customer类 id属性\r\n\r\n    Hibernate框架使用OID来区分不同PO对象 \r\n        * 例如内存中有两个PO对象，只要具有相同 OID， Hibernate认为同一个对象 \r\n    * Hibernate 不允许缓存同样OID的两个不同对象\r\n\r\n     \r\n\r\n①瞬时态(临时态、自由态)：不存在持久化标识OID，尚未与Hibernate Session关联对象，被认为处于瞬时态，失去引用将被JVM回收 \r\n②持久态：存在持久化标识OID，与当前session有关联，并且相关联的session没有关闭 ,并且事务未提交 \r\n③脱管态(离线态、游离态)：存在持久化标识OID，但没有与当前session关联，脱管状态改变hibernate不能检测到\r\n\r\n \r\n\r\n    区分三种状态：判断对象是否有OID，判断对象是否与session关联(被一级缓存引用) \r\n\r\n// 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\nBook book =newBook();// 瞬时态(没有OID，未与Session关联)\r\n\r\nbook.setName(\"hibernate精通\");\r\n\r\nbook.setPrice(56d);\r\n\r\n \r\n\r\nsession.save(book);// 持久态(具有OID，与Session关联)\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();\r\n\r\nsession.close();\r\n\r\n \r\n\r\nSystem.out.println(book.getId());// 脱管态(具有 OID，与Session断开关联)\r\n\r\n持久化对象状态转换\r\n\r\n     \r\n\r\n    ①瞬时态对象：通过new获得 \r\n\r\n        瞬时----->持久    save、saveOrUpdate(都是session)\r\n\r\n        瞬时----->脱管    book.setId(1) 为瞬时对象设置OID \r\n\r\n \r\n\r\n    ②持久态对象：通过get/load 、Query查询获得\r\n\r\n持久----->瞬时    delete  （被删除持久化对象 不建议再次使用 ）\r\n\r\n持久----->脱管    evict(清除一级缓存中某一个对象)、close(关闭Session，清除一级缓存)、clear(清除一级缓存所有对象 )\r\n\r\n \r\n\r\n    ③脱管态对象 无法直接获得\r\n\r\n脱管----->瞬时    book.setId(null); 删除对象OID\r\n\r\n脱管----->持久    update、saveOrUpdate、 lock(过时)\r\n\r\n11.Hibernate中怎样处理事务?\r\nHibernate是对JDBC的轻量级对象封装，Hibernate本身是不具备Transaction 处理功能的，Hibernate的Transaction实际上是底层的JDBC Transaction的封装，或者是JTA Transaction的封装，下面我们详细的分析： \r\nHibernate可以配置为JDBCTransaction或者是JTATransaction，这取决于你在hibernate.properties中的配置: \r\n#hibernate.transaction.factory_class net.sf.hibernate.transaction.JTATransactionFactory\r\n#hibernate.transaction.factory_class net.sf.hibernate.transaction.JDBCTransactionFactory\r\n如果你什么都不配置，默认情况下使用JDBCTransaction，如果你配置为：\r\n\r\nhibernate.transaction.factory_class net.sf.hibernate.transaction.JTATransactionFactory \r\n将使用JTATransaction，不管你准备让Hibernate使用JDBCTransaction，还是JTATransaction，我的忠告就是什么都不配，将让它保持默认状态，如下：  \r\n#hibernate.transaction.factory_class net.sf.hibernate.transaction.JTATransactionFactory\r\n#hibernate.transaction.factory_class net.sf.hibernate.transaction.JDBCTransactionFactory\r\n在下面的分析中我会给出原因。\r\n\r\n一、JDBC Transaction \r\n看看使用JDBC Transaction的时候我们的代码例子： \r\nSession session = sf.openSession();\r\nTransaction tx = session.beginTransactioin();\r\n...\r\nsession.flush();\r\ntx.commit();\r\nsession.close();\r\n这是默认的情况，当你在代码中使用Hibernate的Transaction的时候实际上就是JDBCTransaction。那么JDBCTransaction究竟是什么东西呢？来看看源代码就清楚了：\r\n\r\nHibernate2.0.3源代码中的类 \r\nnet.sf.hibernate.transaction.JDBCTransaction:\r\npublic void begin() throws HibernateException {\r\n    ...\r\n    if (toggleAutoCommit) session.connection().setAutoCommit(false);\r\n    ...\r\n}\r\n这是启动Transaction的方法，看到 connection().setAutoCommit(false) 了吗？是不是很熟悉？\r\n\r\n再来看 \r\npublic void commit() throws HibernateException {\r\n    ...\r\n    try {\r\n        if ( session.getFlushMode()!=FlushMode.NEVER ) session.flush();\r\n    try {\r\n        session.connection().commit();\r\n        committed = true;\r\n    }\r\n    ...\r\n    toggleAutoCommit();\r\n}\r\n这是提交方法，看到connection().commit() 了吗？下面就不用我多说了，这个类代码非常简单易懂，通过阅读使我们明白Hibernate的Transaction都在干了些什么？我现在把用 Hibernate写的例子翻译成JDBC，大家就一目了然了：\r\n\r\nConnection conn = ...; <--- session = sf.openSession();\r\nconn.setAutoCommit(false); <--- tx = session.beginTransactioin();\r\n... <--- ...\r\nconn.commit(); <--- tx.commit(); (对应左边的两句)\r\nconn.setAutoCommit(true);\r\nconn.close(); <--- session.close();\r\n    看明白了吧，Hibernate的JDBCTransaction根本就是conn.commit而已，根本毫无神秘可言，只不过在Hibernate中， Session打开的时候，就会自动conn.setAutoCommit(false)，不像一般的JDBC，默认都是true，所以你最后不写 commit也没有关系，由于Hibernate已经把AutoCommit给关掉了，所以用Hibernate的时候，你在程序中不写 Transaction的话，数据库根本就没有反应。\r\n\r\n12.简单的介绍一下Hibernate的核心API？\r\n1.Configuration\r\n\r\n    用于加载hibernate配置\r\n\r\n    ①加载核心属性配置hibernate.properties和hibernate.cfg.xml\r\n\r\n//方式一：去src 读取 hibernate.properties 属性配置文件\r\n\r\nConfiguration cfg =newConfiguration(); \r\n\r\n//方式二：去src读取 hibernate.cfg.xml  \r\n\r\nConfiguration cfg =newConfiguration().configure(); \r\n\r\n Configuration cfg =newConfiguration().configure(\"自定义xml文件\");去src 加载指定文件 \r\n\r\n \r\n\r\n    ②手动加载hbm映射配置，持久化类与数据表的映射关系（*.hbm.xml 文件）\r\n\r\n如果没有对PO类进行hbm映射，会报错 ：\r\n\r\norg.hibernate.MappingException:Unknown entity: cn.itcast.domain.Customer \r\n\r\n        那么我们可以手动加载其映射文件：\r\n\r\n//方式一：\r\n\r\nconfiguration.addResource(\"cn/itcast/domain/Customer.hbm.xml\");加载hbm文件 \r\n\r\n//方式二：\r\n\r\nconfiguration.addClass(Customer.class);加载Class，自动搜索hbm映射文件\r\n\r\n    * 如果使用 hibernate.cfg.xml配置，将映射配置xml中 <mapping resource=\"cn/itcast/domain/Customer.hbm.xml\"/>\r\n\r\n \r\n\r\n2.SessionFactory\r\n\r\n    ①保存了当前的数据库配置信息和所有映射关系以及预定义的SQL语句这个对象是线程安全的\r\n\r\n//预定义SQL语句\r\n\r\n<sql-queryname=\"login\">\r\n\r\n    <![CDATA[select * from user where username= ? and password =?]]>\r\n\r\n</sql-query>\r\n\r\n3.Session\r\n\r\n    代表hibernate操作会话对象，相当于Connection \r\n\r\nsession是一个单线程对象，线程不安全（在方法内部定义和使用Session，不会出现线程问题）\r\n\r\n* 每个线程方法调用栈，是线程私有的\r\n\r\nsession 进行PO(Persistent Object)对象常见持久化操作, 存在一级缓存\r\n\r\n    常用API\r\n\r\nsave 完成插入\r\n\r\nupdate 完成修改\r\n\r\ndelete完成删除\r\n\r\nget/load 根据主键字段查询\r\n\r\ncreateQuery、 createSQLQuery 创建查询对象Query接收HQL，SQLQuery接收SQL\r\n\r\ncreateCriteria()  面向对象条件查询\r\n\r\n4.Transaction 事务操作\r\n\r\ncommit 提交\r\n\r\nrollback 回滚\r\n\r\n \r\n\r\n    如果没有开启事务，那么每个Session的操作，都相当于一个独立的事务\r\n\r\n* 事务是否提交\r\n\r\n//默认false \r\n\r\n<property name=\"hibernate.connection.autocommit\">false</property> 事务不提交\r\n\r\n<propertyname=\"hibernate.connection.autocommit\">true</property> 事务提交\r\n\r\n5.Query\r\n\r\n    session.createQuery()获得\r\n\r\n面向对象查询，操作类，操作属性\r\n\r\n接收参数 HQL语句\r\n\r\n开发代码步骤\r\n\r\n    获得HibernateSession对象\r\n\r\n    编写HQL语句\r\n\r\n    调用session.createQuery 创建查询对象\r\n\r\n    如果HQL语句包含参数，则调用Query的setXXX设置参数\r\n\r\n    调用Query对象的list()或uniqueResult()方法执行查询\r\n\r\n6.Criteria 接口（QBC查询 Query By Criteria ）\r\n\r\n  主要为了解决多条件查询问题，以面向对象的方式添加条件，无需拼接HQL语句 \r\n\r\n13.update与saveOrUpdate有什么区别？\r\nsave() 方法很显然是执行保存操作的，如果是对一个新的刚new出来的对象进行保存，自然要使用这个方法了，数据库中没有这个对象。 \r\nupdate() 如果是对一个已经存在的托管对象进行更新那么肯定是要使用update（）方法了，数据中有这个对象。 \r\nsaveOrUpdate() 这个方法是更新或者插入，有主键就执行更新，如果没有主键就执行插入。【此方法慎用】\r\n\r\n    在Hibernate中saveOrUpdate()方法在执行的时候，先会去session中去找存不存在指定的字段，如果存在直接update，否则save，这个时候问题就发生了。 \r\n    有两张表，表A和表B，这两张表的主键都是一样的，例如都是MASTER_ID，同时对应的BO里面属性都是masterID，现在要执行的操作是，以 MASTER_ID为条件将表A中的数据查询出来，然后将部分值插入到表B中，然后再更新表B，在查询表A后，session中已经存在masterID 了，这个时候再去对表B进行savaOrUpdate的时候，Hibernate会发现session中已经存在masterID了，所以执行的就是 update，但是实际上表B中根本不存在masterID这个值，当你执行完查询数据库的时候会发现没有插入数据，像这种情况，就得先用 masterID对表B进行查询，当返回的BO为NULL时，new一个新BO然后再进行插入，这个时候用到的就是createbo了。\r\n\r\n14.Hibernate的inverse属性的作用？\r\n1．明确inverse和cascade的作用  \r\ninverse 决定是否把对对象中集合的改动反映到数据库中，所以inverse只对集合起作用，也就是只对one-to-many或many-to-many有效（因为只有这两种关联关系包含集合，而one-to-one和many-to-one只含有关系对方的一个引用）。 \r\ncascade决定是否把对对象的改动反映到数据库中，所以cascade对所有的关联关系都起作用（因为关联关系就是指对象之间的关联关系）。\r\n\r\n\r\n2.inverse属性 ：inverse所描述的是对象之间关联关系的维护方式。 \r\ninverse只存在于集合标记的元素中 。Hibernate提供的集合元素包括<set/> <map/> <list/> <array /> <bag /> \r\nInverse属性的作用是：是否将对集合对象的修改反映到数据库中。 inverse属性的默认值为false，表示对集合对象的修改会被反映到数据库中；inverse=false 的为主动方，由主动方负责维护关联关系。  inverse=”true” 表示对集合对象的修改不会被反映到数据库中。为了维持两个实体类（表）的关系，而添加的一些属性，该属性可能在两个实体类（表）或者在一个独立的表里面，这个要看这双方直接的对应关系了： 这里的维护指的是当主控放进行增删改查操作时，会同时对关联关系进行对应的更新。 \r\n   一对多： 该属性在多的一方。应该在一方的设置 inverse=true ，多的一方设置 inverse=false（多的一方也可以不设置inverse属性，因为默认值是false），这说明关联关系由多的一方来维护。如果要一方维护关 系，就会使在插入或是删除\"一\"方时去update\"多\"方的每一个与这个\"一\"的对象有关系的对象。而如果让\"多\"方面维护关系时就不会有update 操作，因为关系就是在多方的对象中的，直指插入或是删除多方对象就行了。显然这样做的话，会减少很多操作，提高了效率。\r\n\r\n注：单向one-to-many关联关系中，不可以设置inverse=\"true\",因为被控方的映射文件中没有主控方的信息。 \r\n   多对多： 属性在独立表中。inverse属性的默认值为false。在多对多关联关系中，关系的两端 inverse不能都设为false,即默认的情况是不对的，如果都设为false,在做插入操作时会导致在关系表中插入两次关系。也不能都设为 true，如果都设为true,任何操作都不会触发对关系表的操作。因此在任意一方设置inverse=true，另一方inverse=false。 \r\n   一对一： 其实是一对多的一个特例,inverse 的设置也是一样的，主要还是看关联关系的属性在哪一方，这一方的inverse=false。 \r\n   多对一： 也就是一对多的反过来，没什么区别。\r\n\r\n\r\n3.cascade属性 \r\n级联操作：指当主控方执行某项操作时，是否要对被关联方也执行相同的操作。 \r\n\r\ncascade属性的作用是描述关联对象进行操作时的级联特性。因此，只有涉及到关系的元素才有cascade属性。具有cascade属性的标记包括<many-to-one /> <one-to-one /> <any /> <set /><bag /> <idbag /> <list /> <array /> \r\n注意：<one-to-many />和 <many-to-many />是用在集合标记内部的，所以是不需要cascade属性的。 \r\n\r\n4.inverse和cascade的区别 \r\n作用的范围不同： \r\n    Inverse是设置在集合元素中的。 \r\n    Cascade对于所有涉及到关联的元素都有效。 \r\n    <many-to-one/><ont-to-many/>没有inverse属性，但有cascade属性 \r\n执行的策略不同 \r\n    Inverse 会首先判断集合的变化情况，然后针对变化执行相应的处理。 \r\n    Cascade 是直接对集合中每个元素执行相应的处理 \r\n执行的时机不同 \r\n    Inverse是在执行SQL语句之前判断是否要执行该SQL语句 \r\n    Cascade则在主控方发生操作时用来判断是否要进行级联操作 \r\n执行的目标不同 \r\n    Inverse对于<ont-to-many>和<many-to-many>处理方式不相同。 \r\n    对于<ont-to-many>，inverse所处理的是对被关联表进行修改操作。 \r\n    对于<many-to-many>，inverse所处理的则是中间关联表 \r\n    Cascade不会区分这两种关系的差别，所做的操作都是针对被关联的对象。 \r\n总结：  \r\n<one-to-many> \r\n    <one-to-many>中，建议inverse=”true”，由“many”方来进行关联关系的维护 \r\n    <many-to-many>中，只设置其中一方inverse=”false”，或双方都不设置 \r\n    Cascade，通常情况下都不会使用。特别是删除，一定要慎重。 \r\n操作建议：\r\n\r\n    一般对many-to-one和many-to-many不设置级联，这要看业务逻辑的需要;对one-to-one和one-to-many设置级联。 \r\n    many-to-many关联关系中，一端设置inverse=”false”，另一端设置为inverse=”true”。在one-to-many关联关系中，设置inverse=”true”,由多端来维护关系表\r\n\r\n \r\n\r\nHibernate一级缓存相关问题\r\n1.Session中的一级缓存\r\n\r\n    Hibernate框架共有两级缓存， 一级缓存（Session级别缓存）、二级缓存（SessionFactory级别缓存）\r\n\r\n    在Session接口的实现中包含一系列的 Java 集合, 这些 Java 集合构成了 Session 缓存.  持久化对象保存Session一级缓存中(一级缓存引用持久化对象地址)，只要 Session 实例没有结束生命周期, 存放在它缓存中的对象也不会结束生命周期\r\n\r\n    Hibernate Session接口的实现类SessionImpl类(查看源码，右击session，选择Open Type Hierarchy) ，里面有2个重要的字段：\r\n\r\n*private transient ActionQueue actionQueue;                       ----行动队列(标记数据活动)\r\n\r\n*private transient StatefulPersistenceContext persistenceContext;----持久化上下文 \r\n\r\n    当session的save()方法持久化一个对象时，该对象被载入缓存，以后即使程序中不再引用该对象，只要缓存不清空，该对象仍然处于生命周期中。当试图get()、 load()对象时，会判断缓存中是否存在该对象，有则返回，此时不查询数据库。没有再查询数据库\r\n\r\n    Session 能够在某些时间点, 按照缓存中对象的变化来执行相关的 SQL 语句, 来同步更新数据库, 这一过程被称为刷出缓存(flush)\r\n\r\n        *  Transaction的commit（）\r\n\r\n        *  应用程序执行一些查询操作时\r\n\r\n        *  调用Session的flush()方法\r\n\r\n \r\n\r\n    ①验证一级缓存的存在\r\n\r\nBook book =(Book) session.get(Book.class,1);// 第一次查询，缓存中没有\r\n\r\nSystem.out.println(book);\r\n\r\n \r\n\r\nBook book2 =(Book) session.get(Book.class,1);// 因为第一次查询，对象已经被放入1级缓存，不会查询数据\r\n\r\nSystem.out.println(book2);\r\n\r\n \r\n\r\n*生成一条SQL语句，返回同一个对象，第一次查询生成SQL，查询对象，将对象放入一级缓存，第二次查询，直接从一级缓存获得\r\n\r\n    \r\n\r\n \r\n\r\n \r\n\r\n    ②测试Hibernate快照 (深入理解一级缓存内存结构原理)\r\n\r\n    hibernate 向一级缓存放入数据时，同时保存快照数据(数据库备份)，当修改一级缓存数据，在flush操作时，对比缓存和快照，如果不一致，自动更新(将缓存的内容同步到数据库，更新快照)\r\n\r\n \r\n\r\n*  快照区使用，在Session 保存一份与数据库相同的数据，在session的flush时， 通过快照区比较得知一级缓存数据是否改变，如果改变执行对应操作（update）\r\n\r\n/**\r\n\r\n* 测试快照区的使用\r\n\r\n  */\r\n\r\n@Test\r\n\r\npublicvoid demo3(){\r\n\r\n    // 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\n// 查询id 为1 的图书对象\r\n\r\nBook book =(Book) session.get(Book.class,1);// 第一次查询，将对象加入一级缓存\r\n\r\nSystem.out.println(book);\r\n\r\n \r\n\r\nbook.setName(\"深入浅出Hibernate技术\");// 修改书名（一级缓存被修改，自动update）\r\n\r\n \r\n\r\n// 没有手动执行update，因为快照区原因，自动更新\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();\r\n\r\nsession.close();\r\n\r\n}\r\n\r\n    使用Debug模式进行截图说明：\r\n\r\n    我们重点关注session中的2个属性actionQueue和persistenceContext\r\n\r\n\r\n\r\n    大白话解析：\r\n\r\n        **当执行get后，缓存里面有数据了，活动队列没有发生变化，说明没有需要提交到数据的内容，而PersistenceContext里面有内容了。\r\n\r\n            我们说，持久化上下文里面存放的是一个Map，它的键为一级缓存对象，值为快照(它是一级缓存对象的一个副本)。 \r\n\r\n        **当执行setName后，一级缓存里面的数据发生了改变，在缓存flush时，会对比缓存和快照，如果不一致，那么会将缓存中的内容同步到数据库，并更新快照！\r\n\r\n \r\n\r\n*  Hibernate中 持久态 对象具有自动更新数据库能力 （持久态对象 才保存在 Session中，才有快照 ）\r\n\r\n \r\n\r\n2.一级缓存常见操作\r\n\r\n    所有操作需要使用断点调试才能看得比较清楚！\r\n\r\n    1)flush ： 修改一级缓存数据针对内存操作，需要在session执行flush操作时，将缓存变化同步到数据库\r\n\r\n     * 只有在缓存数据与快照区不同时，生成update语句\r\n\r\n    2)clear ： 清除所有对象 一级缓存\r\n\r\n    3)evict ： 清除一级缓存指定对象\r\n\r\n    4)refresh ：重新查询数据库，更新快照和一级缓存\r\n\r\n@Test\r\n\r\n// Session 对于 一级缓存操作\r\n\r\npublicvoid demo4(){\r\n\r\n// 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\n// 查询id 为1 的图书对象\r\n\r\nBook book =(Book) session.get(Book.class,1);// 第一次查询，将对象加入一级缓存\r\n\r\nSystem.out.println(book);\r\n\r\n \r\n\r\n// book.setPrice(80d); // 修改一级缓存数据\r\n\r\n// 将缓存内容同步到数据库\r\n\r\n// session.flush();\r\n\r\n \r\n\r\n// 清除一级缓存所有数据\r\n\r\n// session.clear();\r\n\r\n \r\n\r\n// 清除一级缓存中 指定对象\r\n\r\n// session.evict(book);\r\n\r\n \r\n\r\nbook.setPrice(30d);// 一级缓存改变\r\n\r\nsession.refresh(book);// 用数据库内容 覆盖快照区和一级缓存\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();\r\n\r\nsession.close();\r\n\r\n}\r\n\r\n \r\n\r\n3.一级缓存刷出时间点设置 （FlushMode）\r\n\r\nALWAYS ：在每次查询时，session都会flush  （不要求 ）\r\n\r\nAUTO   : 在有些查询时，session会flush  （默认）  ---------- 查询、commit 、session.flush\r\n\r\nCOMMIT : 在事务提交时，session会flush   ------- commit 、session.flush\r\n\r\nMANUAL ：只有手动调用  session.flush 才会刷出  ----  session.flush\r\n\r\n \r\n\r\n刷出条件(时间点严格程度 )\r\n\r\nMANUAL > COMMIT> AUTO> ALWAYS\r\n\r\n@Test\r\n\r\n// 理解 FlushMode作用\r\n\r\npublicvoid demo5(){\r\n\r\n// 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n \r\n\r\n// 设置 flushMode\r\n\r\nsession.setFlushMode(FlushMode.MANUAL);\r\n\r\n \r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\n// 查询id 为1 的图书对象\r\n\r\nBook book =(Book) session.get(Book.class,1);// 第一次查询，将对象加入一级缓存\r\n\r\nSystem.out.println(book);\r\n\r\n \r\n\r\nbook.setPrice(1000d);// 修改价格\r\n\r\n \r\n\r\nsession.createQuery(\"from Book\").list();// 查询所有图书 （AUTO 级别 flush）\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();// (COMMIT 级别 flush)\r\n\r\n \r\n\r\n// session.flush(); // MANUAL 级别 flush\r\n\r\n \r\n\r\nsession.close();\r\n\r\n}\r\n\r\n \r\n\r\n4.session持久化对象操作方法\r\n\r\n    1) save 将数据保存到数据库 ， 将瞬时对象转换持久对象 \r\n\r\n持久化对象，不允许随便修改 OID\r\n\r\n \r\n\r\n    2) update 更新数据 ，主要用于脱管对象的更新（持久对象，可以根据快照自动更新 ）， 将脱管对象转换持久对象        \r\n\r\n@Test\r\n\r\n// 脱管对象更新\r\n\r\npublicvoid demo6(){\r\n\r\n// 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\nBook book =newBook();// 瞬时\r\n\r\nbook.setId(1);// 脱管\r\n\r\nbook.setName(\"java入门\");\r\n\r\nbook.setPrice(40d);\r\n\r\n \r\n\r\nsession.update(book);// 持久\r\n\r\n \r\n\r\nsession.flush();\r\n\r\n \r\n\r\n// book.setPrice(50d);\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();\r\n\r\nsession.close();\r\n\r\n}\r\n\r\n        问题一： 调用update，默认直接生成update语句，如果数据没有改变，不希望生成update\r\n\r\n    在hbm文件 <class>元素 添加 select-before-update=\"true\"\r\n\r\n<classname=\"cn.itcast.domain.firstcache.Book\"table=\"book\"catalog=\"hibernate3day2\"select-before-update=\"true\">\r\n\r\n问题二： 当update，脱管对象变为持久对象， 一级缓存不允许出现相同OID 两个持久对象\r\n\r\n@Test\r\n\r\n// 一级缓存 存在两个相同OID 持久态对象 报错\r\n\r\npublicvoid demo7(){\r\n\r\n// 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\n// 查询\r\n\r\n// Book b = (Book) session.get(Book.class, 1); // 持久\r\n\r\n \r\n\r\nBook book =newBook();// 瞬时\r\n\r\nbook.setId(1);// 脱管\r\n\r\nbook.setName(\"java入门\");\r\n\r\nbook.setPrice(50d);\r\n\r\nsession.update(book);// 持久\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();\r\n\r\nsession.close();\r\n\r\n}\r\n\r\n    org.hibernate.NonUniqueObjectException: a different object with the same identifier value was already associated with the session: [cn.itcast.domain.firstcache.Book#1]\r\n\r\n问题三： 脱管对象 OID 在数据表中不存在，update时，发生异常\r\n\r\n    org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [cn.itcast.domain.firstcache.Book#20]\r\n\r\n \r\n\r\n    3) saveOrUpdate , 如果参数是一个瞬时对象执行save， 如果参数是一个脱管对象执行update， 如果参数是持久对象直接返回\r\n\r\n判断对象是瞬时对象 ： OID为null ， 在hbm文件中为 <id>元素指定 unsaved-value属性，如果PO对象OID为 unsaved-value 也是瞬时对象\r\n\r\n<id name=\"id\" unsaved-value=\"-1\">  如果对象 OID为-1 也是瞬时对象，此时执行的是save操作\r\n\r\n@Test\r\n\r\n// PO对象，OID为 hbm文件 配置 unsaved-value 也是瞬时对象， saveOrUpdate 执行 save操作\r\n\r\npublicvoid demo8(){\r\n\r\n// 获得Session\r\n\r\nSession session =HibernateUtils.openSession();\r\n\r\n// 开启事务\r\n\r\nTransaction transaction = session.beginTransaction();\r\n\r\n \r\n\r\nBook book =newBook();// 瞬时\r\n\r\nbook.setId(-1);// 存在OID , -1是unsaved-value 也是瞬时\r\n\r\nbook.setName(\"xxx\");\r\n\r\nbook.setPrice(100d);\r\n\r\n \r\n\r\nsession.saveOrUpdate(book);\r\n\r\n \r\n\r\n// 提交事务，关闭Session\r\n\r\ntransaction.commit();\r\n\r\nsession.close();\r\n\r\n}\r\n\r\n \r\n\r\n    4) get/load\r\n\r\n        如果查询OID不存在， get方法返回 null ， load 方法返回代理对象 （代理对象初始化时抛出 ObjectNotFoundException ）\r\n\r\n \r\n\r\n    5) delete 方法既可以删除一个脱管对象, 也可以删除一个持久化对象\r\n\r\n        **如果删除脱管，先将脱管对象 与 Session 关联，然后再删除\r\n\r\n**执行delete，先删除一级缓存数据，在session.flush 操作时，删除数据表中数据\r\n\r\n \r\n\r\nHibernate二级缓存相关问题\r\n1.二级缓存的相关介绍\r\n\r\n缓存好处： 将数据库或者硬盘数据，保存在内存中，减少数据库查询次数，减少硬盘交互，提高检索效率\r\n\r\n    hibernate 共有两个级别的缓存\r\n\r\n        * 一级缓存，保存Session中， 事务范围的缓存\r\n\r\n        * 二级缓存，保存SessionFactory ，进程范围的缓存\r\n\r\n    SessionFacoty 两部分缓存\r\n\r\n    内置 ：Hibernate 自带的, 不可卸载. 通常在 Hibernate 的初始化阶段, Hibernate 会把映射元数据和预定义的 SQL 语句放到SessionFactory 的缓存中, 映射元数据是映射文件中数据的复制, 而预定义 SQL 语句时 Hibernate 根据映射元数据推到出来的. 该内置缓存是只读的.\r\n\r\n \r\n\r\n    外置 ：一个可配置的缓存插件. 在默认情况下, SessionFactory 不会启用这个缓存插件. 外置缓存中的数据是数据库数据的复制, 外置缓存的物理介质可以是内存或硬盘，必须引入第三方缓存插件才能使用。\r\n\r\n \r\n\r\n2.二级缓存的内部结构以及存储特点\r\n\r\nHibernate二级缓存分为：   \r\n\r\n    * 类缓存区域\r\n\r\n    * 集合缓存区域 \r\n    * 更新时间戳区域 \r\n    * 查询缓存区域\r\n\r\n \r\n\r\n \r\n\r\n类缓存区数据存储特点\r\n\r\n* 从二级缓存区返回数据每次地址都是不同的（散装数据 ）。每次查询二级缓存，都是将散装数据构造为一个新的对象 \r\n\r\n\r\n\r\n集合缓存区\r\n\r\n\r\n\r\n如果注释掉 Order类缓存，orders 集合无法缓存 \r\n\r\n* 集合缓存区数据缓存依赖类缓存区数据缓存\r\n\r\n \r\n\r\n** 一级缓存的操作会同步到二级缓存\r\n\r\n更新时间戳区域\r\n\r\n作用：记录数据最后更新时间，确保缓存数据是有效的\r\n\r\n    Hibernate 提供了和查询相关的缓存区域:\r\n\r\n    **时间戳缓存区域: org.hibernate.cahce.UpdateTimestampCache \r\n    时间戳缓存区域存放了对于查询结果相关的表进行插入, 更新或删除操作的时间戳.  Hibernate 通过时间戳缓存区域来判断被缓存的查询结果是否过期, 其运行过程如下: \r\n    T1 时刻执行查询操作, 把查询结果存放在 QueryCache 区域, 记录该区域的时间戳为 T1 \r\n    T2 时刻对查询结果相关的表进行更新操作, Hibernate 把 T2 时刻存放在 UpdateTimestampCache 区域. \r\n    T3 时刻执行查询结果前, 先比较 QueryCache 区域的时间戳和 UpdateTimestampCache 区域的时间戳, 若 T2 >T1, 那么就丢弃原先存放在QueryCache 区域的查询结果, 重新到数据库中查询数据, 再把结果存放到 QueryCache 区域; 若 T2 < T1, 直接从 QueryCache 中获得查询结果。\r\n\r\n\r\n\r\n**更新时间戳区域，记录数据最后更新时间，在使用二级缓存时，比较缓存时间t1 与更新时间 t2 ， 如果 t2 > t1 丢弃原来缓存数据，重新查询缓存\r\n\r\n查询缓存\r\n\r\n    有人称查询缓存 为hibernate 第三级缓存\r\n\r\n* 二级缓存缓存数据都是类对象数据，数据都是缓存在 \"类缓存区域\" ，二级缓存缓存PO类对象，条件(key)是id\r\n\r\n    查询缓存适用场合： \r\n\r\n        **应用程序运行时经常使用查询语句\r\n\r\n        **很少对与查询语句检索到的数据进行插入, 删除和更新操作\r\n\r\n    如果查询条件不是id查询， 缓存数据不是PO类完整对象 =====> 不适合使用二级缓存\r\n\r\n查询缓存： 缓存的是查询数据结果， key是查询生成SQL语句  ， 查询缓存比二级缓存功能更加强大\r\n\r\n \r\n\r\n适用查询缓存的步骤\r\n\r\n    1)配置二级缓存(查询缓存依赖二级缓存)\r\n\r\n    2)启用查询缓存 hibernate.cfg.xml\r\n\r\n \r\n\r\n<property name=\"hibernate.cache.use_query_cache\">true</property>\r\n\r\n    3)必须在程序中指定使用查询缓存\r\n\r\n \r\n\r\nquery.setCacheable(true);\r\n\r\n \r\n\r\n3.二级缓存的并发策略\r\n\r\n    transactional ： 提供Repeatable Read事务隔离级别，缓存支持事务，发生异常的时候，缓存也能够回滚\r\n\r\n    read-write    ： 提供Read Committed事务隔离级别，更新缓存的时候会锁定缓存中的数据\r\n\r\n    nonstrict-read-write ：导致脏读， 很少使用\r\n\r\n    read-only     ： 数据不允许修改，只能查询\r\n\r\n* 很少被修改，不是很重要，允许偶尔的并发问题， 适合放入二级缓存。考虑因素（二级缓存的监控【后面学习】，它是是否采用二级缓存主要参考指标）\r\n\r\n4.Hibernate支持哪些二级缓存技术？ \r\n\r\n    *  EHCache  (主要学习，支持本地缓存，支持分布式缓存)\r\n\r\n        可作为进程范围内的缓存, 存放数据的物理介质可以是内存或硬盘, 对 Hibernate 的查询缓存提供了支持。 \r\n    *  OSCache \r\n        可作为进程范围内的缓存, 存放数据的物理介质可以是内存或硬盘, 提供了丰富的缓存数据过期策略, 对 Hibernate 的查询缓存提供了支持 \r\n    *  SwarmCache \r\n        可作为集群范围内的缓存, 但不支持 Hibernate 的查询缓存 \r\n    *  JBossCache \r\n\r\n        可作为集群范围内的缓存, 支持 Hibernate 的查询缓存\r\n————————————————\r\n版权声明：本文为CSDN博主「kagurawill」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/kagurawill/article/details/82810453','2017-03-03 04:57:18','https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583321455483&di=34e524f79161afa5dce51cee6ce03baa&imgtype=jpg&src=http%3A%2F%2Fimg4.imgtn.bdimg.com%2Fit%2Fu%3D1731623189%2C4246153103%26fm%3D214%26gp%3D0.jpg','搬运','','','','hibernate总结','2017-03-03 04:57:53',4,4,1,'1.为什么要使用Hibernate开发你的项目呢？Hibernate的开发流程是怎么样的？'),
(39,'','','### @RestController\r\n\r\n在SpringMVC中@RestController不需要进行页面的跳转，只返回数据String给请求URL的页面\r\n\r\n\r\n\r\n### @Compoment\r\n\r\n​		@Controller\r\n\r\n​		@Repository\r\n\r\n\r\n\r\n### @Controller（被spring整合）\r\n\r\n@Controller都是return \"index\";用来进行页面的跳转，瞬间蒙蔽。\r\n\r\n\r\n\r\n### @Repository\r\n\r\ndao层\r\n\r\n\r\n\r\n### @RequestMapping(\"/idnex\")\r\n\r\n### @RequestMapping({\"/\",\"/index})\r\n\r\n@RequestMapping(method = RequestMethod.GET) == @GetMapping\r\n\r\n\r\n\r\n@RequestMapping(value = \"/get/{id}\", method = RequestMethod.GET)\r\n\r\n新方法可以简化为：\r\n\r\n@GetMapping(\"/get/{id}\")\r\n\r\n#### 	@GetMapping\r\n\r\n#### 	@PostMapping\r\n\r\n#### 	@PutMapping\r\n\r\n#### 	@DeleteMapping\r\n\r\n#### 	@PatchMapping\r\n\r\n\r\n\r\n### @RequestParam\r\n\r\n用于接收？后的参数\r\n例如：\r\nurl=“http://www.nc.com/queryById?id=${Id}”\r\n后端：\r\n@RequestMapping（“queryById”）\r\npublic String queryById(Model model,@RequsetParam(value = “id”) Long id){\r\n}\r\n\r\n### @PathVaiable\r\n\r\n用于获取url中的值\r\n例如：\r\nurl=“http://www.nc.com/edit/${id}”\r\n后端：\r\n@RequestMapping（“edit/{id}”）\r\npublic String edit(Model model, @PathVailable(“id”) Long id){\r\n}\r\n\r\n\r\n\r\n\r\n\r\n### @Configuration\r\n\r\n@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。\r\n\r\n\r\n\r\n### @Bean\r\n\r\nSpring的@Bean注解用于告诉方法，产生一个Bean对象，然后这个Bean对象交给Spring管理。产生这个Bean对象的方法Spring只会调用一次，随后这个Spring将会将这个Bean对象放在自己的IOC容器中。\r\n\r\nSpringIOC 容器管理一个或者多个bean，这些bean都需要在@Configuration注解下进行创建，在一个方法上使用@Bean注解就表明这个方法需要交给Spring进行管理。\r\n\r\n\r\n\r\n### @ConfigurationProperties\r\n\r\n在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量的参数配置在 application.properties 或 application.yml 文件中，通过 `@ConfigurationProperties` 注解，我们可以方便的获取这些参数值\r\n\r\n\r\n\r\n\r\n\r\n### @Mapper\r\n\r\n表示是一个mybatis的mapper类\r\n\r\n\r\n\r\n### @MapperScan（\"包路径\"）\r\n\r\n也可以不用@Mapper，@MapperScan用这个是在application配置的\r\n\r\n\r\n\r\n### @Autowired\r\n\r\n@Autowired 是一个注释，它可以对类成员变量、方法及构造函数进行标注，让 spring 完成 bean 自动装配的工作。\r\n\r\n　　其实在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性','2020-03-04 08:29:16','https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583320621850&di=5227a80b20ea72dca10b3684f446a6e0&imgtype=0&src=http%3A%2F%2Fwww.lightcg.com%2Fupfile%2F2016%2F05%2F16%2F20160516232000_251.jpg','原创','','','','Spring的注解','2020-03-04 08:30:44',10,2,1,'这个是spring和springmvc框架的的一些注解，我把他们整理起来了，方便大家记忆，复习。'),
(67,'','','环境： Intellij IDEA 2019 CI\r\n\r\n具体步骤：\r\n\r\n### **1、新建Project（此处以创建web项目为例）**\r\n\r\n勾选Web Application + Hibernate\r\n同时勾选 ”Create default hibernate configuration and main class” （当然也可以不勾选，在项目创建好后再手动创建也是一样的）\r\n\r\n[![](https://ae01.alicdn.com/kf/H26778dd052f246ec9b1d145ae8b0cda8Q.png)](https://ae01.alicdn.com/kf/H26778dd052f246ec9b1d145ae8b0cda8Q.png)\r\n\r\n### **2、点击next，填写项目名称，finish**\r\n\r\nIDEA已经帮我们创建好了hibernate.cfg.xml文件、导入了相应的jar包\r\n注：如果是eclipse的用户，jar包自行导入，其他操作也和IDEA的操作一样一样的\r\n[![](https://ae01.alicdn.com/kf/H2b4bba4335c14dbfad5b472a0daa90f67.png)](https://ae01.alicdn.com/kf/H2b4bba4335c14dbfad5b472a0daa90f67.png)\r\n\r\n[![](https://ae01.alicdn.com/kf/H8a6a3a38413a478ead89dc64d69e6387L.png)](https://ae01.alicdn.com/kf/H8a6a3a38413a478ead89dc64d69e6387L.png)\r\n\r\n此时需要自己再导入mysql的链接包\r\n\r\n[![](https://ae01.alicdn.com/kf/H5bc2f2370ab4435abb932707633ecd5dQ.png)](https://ae01.alicdn.com/kf/H5bc2f2370ab4435abb932707633ecd5dQ.png)\r\n### **3、连接数据库（以MySQL为例）**\r\n\r\n（在连接数据库之前，需创建好数据库）\r\n 我用的是SQLyog，先创建一个customer表。\r\n ```sql\r\nCREATE TABLE `customer` (\r\n  `id` int(11) NOT NULL,\r\n  `name` varchar(255) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\r\n```\r\n[![](https://ae01.alicdn.com/kf/H6dfd253d0d2d45a98dd3bc8a545c5997g.png)](https://ae01.alicdn.com/kf/H6dfd253d0d2d45a98dd3bc8a545c5997g.png)\r\n### **4、创建持久化类**\r\n\r\n持久化类满足JavaBean规范，具体路径和类字段、方法见图\r\n[![](https://ae01.alicdn.com/kf/H275b1c1d4c96487285e07e423e838f8cf.png)](https://ae01.alicdn.com/kf/H275b1c1d4c96487285e07e423e838f8cf.png)\r\n```java\r\npackage com.xiaojin;\r\n\r\npublic class Customer {\r\n    \r\n    private int id;\r\n    private String name;\r\n    \r\n    public Customer() {\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Customer{\" +\r\n                \"id=\" + id +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n\r\n```\r\n### **5、创建持久化类的映射文件**\r\n\r\nCustomer.hbm.xml\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\r\n        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\r\n\r\n<hibernate-mapping>\r\n    <!--name：实体类名,table：对应数据库表名-->\r\n    <class name=\"com.xiaojin.Customer\" table=\"customer\">\r\n        <!-- 配置主键映射 -->\r\n        <!--name：实体类的属性名,column：数据库表的字段名,type：数据类型-->\r\n        <id name=\"id\" type=\"java.lang.Integer\">\r\n            <column name=\"id\"></column>\r\n            <!-- 设置主键生成方式 -->\r\n            <generator class=\"native\"></generator>\r\n        </id>\r\n\r\n        <!-- 配置其他属性 -->\r\n        <!--name：实体类的属性名,column：数据库表的字段名,type：数据类型-->\r\n        <property name=\"name\" type=\"java.lang.String\">\r\n            <column name=\"name\"></column>\r\n        </property>\r\n\r\n\r\n    </class>\r\n</hibernate-mapping>\r\n\r\n```\r\n### **6、创建hibernate配置文件**\r\n\r\n因为在新建项目的时候已经自动生成了hibernate配置文件，在这里就直接进行配置即可，也可重新创建新的配置文件进行配置\r\n\r\nhibernate.cfg.xml\r\n```xml\r\n<?xml version=\'1.0\' encoding=\'utf-8\'?>\r\n<!DOCTYPE hibernate-configuration PUBLIC\r\n        \"-//Hibernate/Hibernate Configuration DTD//EN\"\r\n        \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\r\n<hibernate-configuration>\r\n    <session-factory>\r\n        <property name=\"connection.username\">root</property>\r\n        <property name=\"connection.password\">root</property>\r\n        <property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\r\n        <property name=\"connection.url\">jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8</property>\r\n\r\n        <!-- 配置Hibernate的基本信息 -->\r\n        <!-- hibernate 所使用的数据库方言 这个是MySql5.0之前才会自动创建表-->\r\n        <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\r\n        <!--        MySql5.0之后的配置-->\r\n<!--        <property name=\"dialect\">org.hibernate.dialect.MySQL5Dialect</property>-->\r\n<!--                MySql5.0之后的配置 并且生成的表字符集为utf-8，这个是自己重写的方法com.utils.MySQL5DialectUTF8-->\r\n<!--        <property name=\"hibernate.dialect\">com.utils.MySQL5DialectUTF8</property>-->\r\n        <!-- 执行操作时是否在控制台打印 SQL -->\r\n        <property name=\"show_sql\">true</property>\r\n\r\n        <!-- 是否对 SQL 进行格式化 -->\r\n        <property name=\"format_sql\">true</property>\r\n\r\n        <!-- 指定是否自动生成数据库表 -->\r\n        <property name=\"hbm2ddl.auto\">update</property>\r\n\r\n        <!-- 添加实体关系映射文件 -->\r\n        <mapping resource=\"com/xiaojin/Customer.hbm.xml\"/>\r\n        <!-- 采用注解自动生成实体关系映射文件 -->\r\n<!--        <mapping class=\"com.xiaojin.Customer\"></mapping>-->\r\n    </session-factory>\r\n</hibernate-configuration>\r\n```\r\n### **7、创建测试类并测试**\r\n[![](https://ae01.alicdn.com/kf/H182f344bb7024ba4a2e2a3ac212a1dd3J.png)](https://ae01.alicdn.com/kf/H182f344bb7024ba4a2e2a3ac212a1dd3J.png)\r\n测试类\r\n```java\r\npackage com.test;\r\nimport com.xiaojin.Customer;\r\nimport org.hibernate.Session;\r\nimport org.hibernate.SessionFactory;\r\nimport org.hibernate.Transaction;\r\nimport org.hibernate.cfg.Configuration;\r\n\r\n\r\npublic class Test {\r\n\r\n    public static void main(String[] args) {\r\n        Configuration conf=new Configuration();\r\n        conf.configure(\"hibernate.cfg.xml\");\r\n        SessionFactory sessionFactory=conf.buildSessionFactory();\r\n        Session session=sessionFactory.openSession();//创建Session\r\n        Transaction tx=session.beginTransaction();//开启事务\r\n        //上面这个是固定的必要的\r\n\r\n        Customer c=new Customer();\r\n        c.setName(\"小金\");\r\n\r\n        session.save(c);//执行保存\r\n        tx.commit();//提交事务\r\n\r\n        //关闭\r\n        session.close();\r\n        sessionFactory.close();\r\n\r\n    }\r\n}\r\n\r\n```\r\n运行成功后如同：\r\n[![](https://ae01.alicdn.com/kf/He65ccc80cb544a2eb69c540d9bcd9841M.png)](https://ae01.alicdn.com/kf/He65ccc80cb544a2eb69c540d9bcd9841M.png)\r\n\r\n##**补充**：\r\n如果想要自动生成表的话，只要把hibernate.cfg.xml配置文件中的\r\nhbm2ddl.auto改为update就可以了。\r\n```xml\r\n <!-- 指定是否自动生成数据库表 -->\r\n   <property name=\"hbm2ddl.auto\">update</property>\r\n```\r\n*如果出错的话请看这里：\r\n1、hibernate.dialect改为org.hibernate.dialect.MySQL5Dialect\r\n2、如果表中的字符集不是utf-8，自己重写一个MySQL5DialectUTF8\r\n3、如果表中的字符集不是utf-8，jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8后面记得加characterEncoding=utf-8\r\n*\r\nMySQL5DialectUTF8类\r\n```java\r\npackage com.utils;\r\n\r\nimport org.hibernate.dialect.MySQL5InnoDBDialect;\r\n\r\npublic class MySQL5DialectUTF8 extends MySQL5InnoDBDialect {\r\n    @Override\r\n    public String getTableTypeString() {\r\n        return \" ENGINE=InnoDB DEFAULT CHARSET=utf8\";\r\n    }\r\n}\r\n\r\n```\r\n解决以上问题后，运行，就算之前没有创建customer表，hibernate也会自动创建。\r\n\r\n###**使用注解**\r\n```java\r\npackage com.xiaojin;\r\n\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\n\r\n@Entity\r\n@Table(name = \"customer\")\r\npublic class Customer {\r\n\r\n    @Id\r\n    @GeneratedValue\r\n    private int id;\r\n    private String name;\r\n\r\n\r\n    public Customer() {\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(int id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"Customer{\" +\r\n                \"id=\" + id +\r\n                \", name=\'\" + name + \'\\\'\' +\r\n                \'}\';\r\n    }\r\n}\r\n\r\n\r\n```\r\n并且在hibernate.cfg.xml加上\r\n```xml\r\n<!-- 采用注解自动生成实体关系映射文件 -->\r\n        <mapping class=\"com.xiaojin.Customer\"></mapping>\r\n```\r\n\r\n以上内容如果有帮助的话，还请多多关注，如果想要看更多更加详细的博客，请到我的博客来，继续关注我，大家一起讨论学习！！！','2020-03-05 16:50:55','https://ae01.alicdn.com/kf/H99579870511a4bd4976fa65883d743c2M.jpg','原创','','','','Intellij IDEA创建第一个hibernate项目','2020-03-05 17:14:58',29,64,1,'最近学习了spring，做了一个项目，里面设计到的技术有hibernate，但是之前学习的都忘记得差不多了，刚好借此机会好好整理一下，顺便帮大家们讲解一下一起学习学习。小白一个，大佬勿喷。'),
(72,'','','# 一、一对多关系\r\n\r\n## 1.概念\r\n一对多关系是关系型数据库中两个表之间的一种关系。通常在数据库层级中，两表之间是有主外键关系的。在ORM中，如何通过对象描述表之间的关系，是ORM核心。\r\n\r\n## 2.Hibernate的一对多关联映射【重点】\r\n**2.1表关系的分析**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020030710172690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDI5MDA3NA==,size_16,color_FFFFFF,t_70)\r\n**MySql语句**\r\n\r\n```sql\r\nCREATE TABLE `t_category` (\r\n  `cid` int(11) NOT NULL AUTO_INCREMENT,\r\n  `cname` varchar(255) DEFAULT NULL,\r\n  PRIMARY KEY (`cid`)\r\n);\r\n​\r\nCREATE TABLE `t_product` (\r\n  `pid` int(11) NOT NULL AUTO_INCREMENT,\r\n  `pname` varchar(255) DEFAULT NULL,\r\n  `price` double DEFAULT NULL,\r\n  `cid` int(11) DEFAULT NULL,\r\n  PRIMARY KEY (`pid`),\r\n  KEY `FKq8yr5sflwtcj3jqp58x0oy7lx` (`cid`),\r\n  CONSTRAINT `FKq8yr5sflwtcj3jqp58x0oy7lx` FOREIGN KEY (`cid`) REFERENCES `t_category` (`cid`)\r\n);\r\n```\r\n**2.2创建持久化类**\r\n\r\n - Category.java(一的一方)\r\n\r\n```java\r\npublic class Category {\r\n    private Integer cid;\r\n    private String cname;\r\n    //在一的一方,用一个集合表示和product的关系\r\n    private Set<Product> products = new HashSet<Product>();\r\n    \r\n    public Integer getCid() {\r\n        return cid;\r\n    }\r\n    public void setCid(Integer cid) {\r\n        this.cid = cid;\r\n    }\r\n    public String getCname() {\r\n        return cname;\r\n    }\r\n    public void setCname(String cname) {\r\n        this.cname = cname;\r\n    }\r\n    public Set<Product> getProducts() {\r\n        return products;\r\n    }\r\n    public void setProducts(Set<Product> products) {\r\n        this.products = products;\r\n    }\r\n}\r\n```\r\n\r\n - Product.java(多的一方)\r\n\r\n```java\r\npublic class Product {\r\n    private Integer pid;\r\n    private String pname;\r\n    private double price;\r\n    //用一个对象表示,当前商品属于哪个类别\r\n    private Category category;\r\n​\r\n    public Integer getPid() {\r\n        return pid;\r\n    }\r\n​\r\n    public void setPid(Integer pid) {\r\n        this.pid = pid;\r\n    }\r\n​\r\n    public String getPname() {\r\n        return pname;\r\n    }\r\n​\r\n    public void setPname(String pname) {\r\n        this.pname = pname;\r\n    }\r\n​\r\n    public double getPrice() {\r\n        return price;\r\n    }\r\n​\r\n    public void setPrice(double price) {\r\n        this.price = price;\r\n    }\r\n​\r\n    public Category getCategory() {\r\n        return category;\r\n    }\r\n​\r\n    public void setCategory(Category category) {\r\n        this.category = category;\r\n    }\r\n    \r\n}\r\n```\r\n**2.3创建映射**\r\n\r\n - 分类的映射\r\n\r\n```xml\r\n<hibernate-mapping>\r\n    <class name=\"com.pri.bean.Category\" table=\"t_category\">\r\n        <!--一,主键属性  -->\r\n        <id name=\"cid\" column=\"cid\">\r\n            <generator class=\"native\"></generator>\r\n        </id>\r\n        <!-- 二,其它属性 -->\r\n        <property name=\"cname\" column=\"cname\"/>\r\n    \r\n        <!-- 三,表示和商品的关系 -->\r\n        <!--3.1 set标签的name属性:多的一方的集合的名字  -->\r\n        <set name=\"products\">\r\n            <!--3.2 key的 column表示多的一方外键名 -->\r\n            <key column=\"cid\"/>\r\n            <!--3.3 one-to-many的class属性表示多的一方类的全限定名  -->\r\n            <one-to-many class=\"com.pri.bean.Product\"/>\r\n        </set>\r\n    </class>\r\n</hibernate-mapping>\r\n```\r\n\r\n - 商品的映射\r\n\r\n```xml\r\n<hibernate-mapping>\r\n    <class name=\"com.pri.bean.Product\" table=\"t_product\">\r\n        <!--一,主键属性  -->\r\n        <id name=\"pid\" column=\"pid\">\r\n            <generator class=\"native\"></generator>\r\n        </id>\r\n        <!-- 二,其它属性 -->\r\n        <property name=\"pname\" column=\"pname\"/>\r\n        <property name=\"price\" column=\"price\"/>\r\n    \r\n        <!-- 三,表示和分类的关系 -->\r\n        <!--3.1name:一的一方对象的名字\r\n              class: 一的一方类的全限定名\r\n              column:外键的名字\r\n          -->\r\n        <many-to-one name=\"category\" class=\"com.pri.bean.Category\" column=\"cid\"/>\r\n    </class>\r\n</hibernate-mapping>\r\n```\r\n\r\n**2.4将映射添加到配置文件**\r\n\r\n```xml\r\n<!-- 三、加载映射关系配置 -->\r\n<mapping resource=\"com/pri/bean/Product.hbm.xml\"/>\r\n<mapping resource=\"com/pri/bean/Category.hbm.xml\"/>\r\n```\r\n**2.5写代码测试**\r\n\r\n - TestDb\r\n \r\n```java\r\npublic class TestDb {\r\n    \r\n    @Test\r\n    public void fun01(){\r\n        Session session = HibernateUtils.openSession();\r\n         Transaction transaction = session.beginTransaction();\r\n       \r\n         transaction.commit();\r\n         session.close();\r\n    }\r\n​\r\n}\r\n```\r\n\r\n## 3.级联操作\r\n\r\n**3.1概念**\r\n​ 　　如果我们对某一个表进行了操作，那么也会顺带对关联表进行操作。或者说当对主对象进行某种操作时是也对其关联的从对象也作类似的操作.\r\n\r\n​ 　　eg:如果我们删除了一个公司，那么就得要求，员工表也得把属于这个公司的所有员工也删除掉。\r\n\r\n​ 　　如果我们删除了一个类别, 那么该类别下的商品是否要删除或者不删除只删除外键,那么这样的操作就属于级联操作了.\r\n\r\n**3.2 级联保存和修改\r\n3.2.1 操作一方级联保存多方【掌握】**\r\n\r\n - 保存Category(一的一方)的时候级联保存Product(多的一方)\r\n   \r\n - 应用场景: 保存一方的同时也需要保存多方(并且多方的数据比较多). eg: 订单和订单项\r\n\r\n```xml\r\n<!-- 三、表示和商品的关系 -->\r\n<!-- 3.1 set标签的name属性：多的一方的集合的名字 -->\r\n<set name=\"products\" cascade=\"save-update\"/>\r\n    <!-- 3.2 key的column表示多的一方外键名 -->\r\n    <key column=\"cid\"/>\r\n    <!-- 3.3 one-to-many的class属性表示多的一方类的全限定名 -->\r\n    <one-to-many class=\"com.pri.bean.Product\"/>\r\n</set>\r\n```\r\n\r\n```java\r\n/**\r\n    * 只保存分类,通过级联把当前分类下的商品也保存\r\n     * 配置: 在category.hbm.xml下设置:\r\n     *      <set cascade=\"save-update\">\r\n     */\r\n    @Test\r\n    public void fun02(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        \r\n        Category c1 = new Category();\r\n        c1.setCname(\"水果\");\r\n        \r\n        Product p1 = new Product();\r\n        p1.setPname(\"苹果\");\r\n        p1.setPrice(5);\r\n        \r\n        //c1和p1 产生关系\r\n        c1.getProducts().add(p1);\r\n        //p1和c1产生关系\r\n        p1.setCategory(c1);\r\n        session.save(c1);\r\n        //session.save(p1);不需要了,通过级联保存特性自动保存\r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n**3.2.2操作多方级联保存一方【了解】**\r\n\r\n```xml\r\n<!--三.表示和分类的关系 -->\r\n<!-- 3.1 name:一的一方对象的名字\r\n        class: 一的一方类的全限定名\r\n        column:外键的名字\r\n-->\r\n<many-to-one name=\"category\" class=\"com.pri.bean.Category\" column=\"cid\" cascade=\"save-update\"/>\r\n```\r\n\r\n - 保存Product(多的一方的)的时候级联保存Category(一的一方)\r\n \r\n\r\n```java\r\n/**\r\n     * 只保存商品,通过级联的特性保存商品对应的分类\r\n     * 配置: 在product.hbm.xml下设置:\r\n     *      <many-to-one cascade=\"save-update\"/>\r\n     */\r\n    @Test\r\n    public void fun03(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        \r\n        Category c1 = new Category();\r\n        c1.setCname(\"水果\");\r\n        \r\n        Product p1 = new Product();\r\n        p1.setPname(\"苹果\");\r\n        p1.setPrice(5);\r\n        \r\n        //p1和c1发生关系\r\n        p1.setCategory(c1);\r\n        \r\n        session.save(p1);\r\n      \r\n        //session.save(c1); 不需要了\r\n        \r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n**3.3级联删除\r\n3.3.1删除一方级联删除多方【掌握】**\r\n\r\n - 删除Category(一的一方)的时候级联删除Product(多的一方)\r\n - 场景: 删除一方的时候确保多方的数据没有任何用途的时候的才会用. eg: 公司和员工\r\n - 实际开发里面很少删除用户的数据. 通常用一个字段标识的\r\n\r\n```xml\r\n<!--  三.表示和商品的关系 -->\r\n<!-- 3.1 set标签的name属性:多的一方的集合的名字 -->\r\n<set name=\"products\" cascade=\"delete\">\r\n    <!--3.2 key 的column表示多的一方外键名 -->\r\n    <key column=\"cid\"/>\r\n    <!-- 3.3 one-to-many的class属性表示多的一方类的全限定名 -->\r\n    <one-to-many class=\"com.pri.bean.Product\"/>\r\n</set>\r\n```\r\n\r\n```java\r\n@Test\r\n//级联删除商品: 删除id为1的类别,级联删除当前类别下的所有商品\r\n//因为删除的是类别,所有在Category.hbm.xml配置:<set name=\"products\" cascade=\"delete\">\r\npublic void fun03(){\r\n      Session session = HibernateUtils.getCurrentSession();\r\n      Transaction transaction = session.beginTransaction();\r\n                 \r\n      //先查 id为1的类别\r\n      Category category = session.get(Category.class, 1);\r\n      session.delete(category);\r\n      transaction.commit();\r\n}\r\n```\r\n**3.3.2 删除多方级联删除一方【了解】**\r\n\r\n - 删除Product(多的一方)的时候级联删除Category(一的一方)\r\n \r\n\r\n```xml\r\n<!--三.表示和分类的关系 -->\r\n     <!-- 3.1 name:一的一方对象的名字\r\n             class: 一的一方类的全限定名\r\n             column:外键的名字\r\n     -->\r\n<many-to-one name=\"category\" class=\"com.pri.bean.Category\" column=\"cid\" cascade=\"delete\"/>\r\n```\r\n\r\n```java\r\n@Test\r\n     //级联删除分类: 删除id为1的商品,级联删除这个商品所属的类别(了解)\r\n     //把当前id为1商品删除,把这个商品所属的类别删除, 商品表里面该类别其它的商品的记录的外键置为null;\r\n     public void fun04(){\r\n         Session session = HibernateUtils.getCurrentSession();\r\n         Transaction transaction = session.beginTransaction();\r\n         \r\n         //先查 id为1的类别\r\n         Product product = session.get(Product.class, 1);\r\n         session.delete(product);\r\n         \r\n         \r\n         transaction.commit();\r\n     }\r\n```\r\n\r\n## 4.外键维护\r\n\r\n**4.1 双向关联产生多余的SQL语句**\r\n​ 　　一旦存在主外键关系，那么外键就由双方对象去维护了， 那么就会造成对这个外键执行了多次操作， 有一次操作其实可以避免的。 也就是说这个外键只要让一个人去维护即可。 外键属于谁，就让谁去维护。\r\n\r\neg:修改产品对应的类别\r\n\r\n**4.2inverse标签属性**\r\n**4.2.1概念**\r\n　　inverse:外键维护，默认为false。代表一方不去维护多方外键。（inverse有反转的意思）外键属于谁, 谁就负责维护.\r\n\r\n**4.2.2一方的放弃外键维护**\r\n只能在一的一方放弃外键维护\r\n\r\n```xml\r\n<set  inverse=\"true\">\r\n    ...\r\n</set>\r\n```\r\n\r\n```xml\r\n<!--  三.表示和商品的关系 -->\r\n<!-- 3.1 set标签的name属性:多的一方的集合的名字 -->\r\n<set name=\"products\" cascade=\"delete\" inverse=\"true\">\r\n    <!--3.2 key 的column表示多的一方外键名 -->\r\n    <key column=\"cid\"/>\r\n    <!-- 3.3 one-to-many的class属性表示多的一方类的全限定名 -->\r\n    <one-to-many class=\"com.pri.bean.Product\"/>\r\n</set>\r\n```\r\n```java\r\n/**\r\n   * 把苹果(p1)的类别设置为水果(c2)\r\n     * 衣服是(c1)\r\n     */\r\n    @Test\r\n    public void fun02(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        //获得苹果\r\n        Product p1 = session.get(Product.class, 1);\r\n        //获得食物类别\r\n        Category c2 = session.get(Category.class, 2);\r\n        \r\n        //p1和c2关联\r\n        p1.setCategory(c2);\r\n        //c2和p1关联\r\n        c2.getProducts().add(p1);\r\n        \r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n\r\n## 二、多对多的关系\r\n\r\n## **1.概念**\r\n\r\n​ 多对多关系是关系数据库中两个表之间的一种数据关系，为了维护这种关系，通常会存在一张中间关系表。两张表都只和关系表间建立主外键关系。\r\n\r\n## **2.Hibernate的多对多关联映射【重点】**\r\n\r\n**2.1表关系的分析**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307102624701.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDI5MDA3NA==,size_16,color_FFFFFF,t_70)\r\n**MySql语句**\r\n\r\n**2.2创建实体**\r\n\r\n - Student.java\r\n\r\n```java\r\npublic class Student {\r\n    \r\n    private Integer sid;\r\n    private String sname;\r\n    \r\n    private Set<Course> courses = new HashSet<Course>();\r\n​\r\n    public Integer getSid() {\r\n        return sid;\r\n    }\r\n​\r\n    public void setSid(Integer sid) {\r\n        this.sid = sid;\r\n    }\r\n​\r\n    public String getSname() {\r\n        return sname;\r\n    }\r\n​\r\n    public void setSname(String sname) {\r\n        this.sname = sname;\r\n    }\r\n​\r\n    public Set<Course> getCourses() {\r\n        return courses;\r\n    }\r\n​\r\n    public void setCourses(Set<Course> courses) {\r\n        this.courses = courses;\r\n    }\r\n    \r\n​\r\n    \r\n}\r\n```\r\n\r\n```java\r\npublic class Course {\r\n    \r\n    private Integer cid;\r\n    private String cname;\r\n    \r\n    private Set<Student> students = new HashSet<Student>();\r\n​\r\n    public Integer getCid() {\r\n        return cid;\r\n    }\r\n​\r\n    public void setCid(Integer cid) {\r\n        this.cid = cid;\r\n    }\r\n​\r\n    public String getCname() {\r\n        return cname;\r\n    }\r\n​\r\n    public void setCname(String cname) {\r\n        this.cname = cname;\r\n    }\r\n​\r\n    public Set<Student> getStudents() {\r\n        return students;\r\n    }\r\n​\r\n    public void setStudents(Set<Student> students) {\r\n        this.students = students;\r\n    }\r\n     \r\n}\r\n```\r\n**2.3创建映射**\r\n\r\n - 学生的映射\r\n \r\n\r\n```xml\r\n<hibernate-mapping>\r\n    <class name=\"com.itheima.bean.Student\" table=\"t_student\">\r\n        <!--一,主键属性  -->\r\n        <id name=\"sid\" column=\"sid\">\r\n            <generator class=\"native\"></generator>\r\n        </id>\r\n        <!-- 二,其它属性 -->\r\n        <property name=\"sname\" column=\"sname\"/>\r\n    \r\n        <!-- 三,表示和课程的关系 -->\r\n        <!--3.1 set标签的name属性:当前类中集合的名字 \r\n                table:第三方表名\r\n             -->\r\n        <set name=\"courses\" table=\"s_c_tab\">\r\n            <!--3.2 key的 column表示当前类在中间表中的外键 -->\r\n            <key column=\"sid\" />\r\n                <!--3.3 many-to-many表示多对多关系\r\n                    column:表示另一方在中间表中的外键\r\n                    class:表示另一方类的全限定名\r\n              -->\r\n            <many-to-many column=\"cid\" class=\"com.itheima.bean.Course\" ></many-to-many>\r\n        </set>\r\n    </class>\r\n</hibernate-mapping>\r\n```\r\n\r\n - 课程的映射\r\n \r\n\r\n```xml\r\n<hibernate-mapping>\r\n    <class name=\"com.itheima.bean.Course\" table=\"t_course\">\r\n        <!--一,主键属性  -->\r\n        <id name=\"cid\" column=\"cid\">\r\n            <generator class=\"native\"></generator>\r\n        </id>\r\n        <!-- 二,其它属性 -->\r\n        <property name=\"cname\" column=\"cname\"/>\r\n    \r\n        <!-- 三,表示和课程的关系 -->\r\n        <!--3.1 set标签的name属性:当前类中集合的名字  \r\n            table:第三方表名\r\n        -->\r\n        <set name=\"students\" table=\"s_c_tab\">\r\n            <!--3.2 key的 column表示当前类在中间表中的外键 -->\r\n            <key column=\"cid\"/>\r\n                <!--3.3 many-to-many表示多对多关系\r\n                    column:表示另一方在中间表中的外键\r\n                    class:表示另一方类的全限定名\r\n              -->\r\n            <many-to-many column=\"sid\" class=\"com.itheima.bean.Student\"></many-to-many>\r\n        </set>\r\n    </class>\r\n</hibernate-mapping>​\r\n```\r\n**2.4将映射添加到配置文件**\r\n\r\n```xml\r\n<!-- 三.加载映射关系配置 -->\r\n<mapping resource=\"com/pri/bean/Student.hbm.xml\"/>\r\n<mapping resource=\"com/pri/bean/Course.hbm.xml\"/>\r\n```\r\n**2.5写代码测试**\r\n\r\n - 保存\r\n \r\n\r\n```java\r\n/**\r\n     * 正常保存\r\n     */\r\n    @Test\r\n    public void fun01(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        \r\n        Student s1 = new Student();\r\n        s1.setSname(\"张三\");\r\n        Student s2 = new Student();\r\n        s2.setSname(\"李四\");\r\n        \r\n        Course c1 = new Course();\r\n        c1.setCname(\"C语言\");\r\n        Course c2 = new Course();\r\n        c2.setCname(\"Java\");\r\n        Course c3 = new Course();\r\n        c3.setCname(\"前端\");\r\n        \r\n        //s1选择了c1和c2\r\n        s1.getCourses().add(c1);\r\n        s1.getCourses().add(c2);\r\n        \r\n        //s2选择了c2 c3\r\n        s2.getCourses().add(c2);\r\n        s2.getCourses().add(c3);\r\n        \r\n        //c1被s1选了\r\n        c1.getStudents().add(s1);\r\n        //c2被s1,s2选了\r\n        c2.getStudents().add(s1);\r\n        c2.getStudents().add(s2);\r\n        //c3被s2选了\r\n        c3.getStudents().add(s2);\r\n        //如果双向关联,一定要一方放弃主键维护\r\n        session.save(s1);\r\n        session.save(s2);\r\n        session.save(c1);\r\n        session.save(c2);\r\n        session.save(c3);\r\n        \r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n\r\n## 3.级联操作\r\n\r\n**3.1级联保存【掌握】**\r\n\r\n - 保存Student级联保存Course\r\n \r\n\r\n```xml\r\n<set name=\"courses\" table=\"s_c_table\" cascade=\"save-update,delete\">\r\n     <!-- 3.2 key的column表示当前类在中间表的外键 -->\r\n     <key column=\"sid\"/>\r\n     <!-- 3.3 many-to-many 表示多对对关系\r\n             column:表示另一方在中间表中的外键\r\n             class:表示另一方类的全限定名\r\n      -->\r\n     <many-to-many class=\"com.pri.bean.Course\" column=\"cid\"/>\r\n</set>\r\n```\r\n\r\n```java\r\n/**\r\n     * 保存Student级联保存Course\r\n     * 在student.hbm.xml里面配置:<set name=\"courses\" table=\"s_c_tab\" cascade=\"save-update\">\r\n     */\r\n    @Test\r\n    public void fun02(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        \r\n        Student s1 = new Student();\r\n        s1.setSname(\"张三\");\r\n        Student s2 = new Student();\r\n        s2.setSname(\"李四\");\r\n        \r\n        Course c1 = new Course();\r\n        c1.setCname(\"C语言\");\r\n        Course c2 = new Course();\r\n        c2.setCname(\"Java\");\r\n        Course c3 = new Course();\r\n        c3.setCname(\"前端\");\r\n        \r\n        //s1选择了c1和c2\r\n        s1.getCourses().add(c1);\r\n        s1.getCourses().add(c2);\r\n        \r\n        //s2选择了c2 c3\r\n        s2.getCourses().add(c2);\r\n        s2.getCourses().add(c3);\r\n        \r\n        //c1被s1选了\r\n        c1.getStudents().add(s1);\r\n        //c2被s1,s2选了\r\n        c2.getStudents().add(s1);\r\n        c2.getStudents().add(s2);\r\n        //c3被s2选了\r\n        c3.getStudents().add(s2);\r\n        //如果双向关联,一定要一方放弃外键维护\r\n        session.save(s1);\r\n        session.save(s2);\r\n    /*  session.save(c1);\r\n        session.save(c2);\r\n        session.save(c3);*/\r\n        \r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n\r\n - 保存Course级联保存Student\r\n\r\n```xml\r\n<!-- 三.表示和课程的关系 -->\r\n<!-- 3.1 set标签的name属性: 当前类中集合的名字 -->\r\n<set name=\"students\" table=\"s_c_table\" cascade=\"save-update\" inverse=\"true\">\r\n      <!-- 3.2 key的column表示当前类在中间表的外键 -->\r\n      <key column=\"cid\"/>\r\n      <!-- 3.3 many-to-many 表示多对对关系\r\n              column:表示另一方在中间表中的外键\r\n              class:表示另一方类的全限定名\r\n      -->\r\n      <many-to-many class=\"com.pri.bean.Student\" column=\"sid\"/>\r\n</set>\r\n```\r\n\r\n```java\r\n/**\r\n     * 保存Course级联保存Student\r\n     * 在Course.hbm.xml里面配置:<set  cascade=\"save-update\">\r\n     */\r\n    @Test\r\n    public void fun03(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        \r\n        Student s1 = new Student();\r\n        s1.setSname(\"张三\");\r\n        Student s2 = new Student();\r\n        s2.setSname(\"李四\");\r\n        \r\n        Course c1 = new Course();\r\n        c1.setCname(\"C语言\");\r\n        Course c2 = new Course();\r\n        c2.setCname(\"Java\");\r\n        Course c3 = new Course();\r\n        c3.setCname(\"前端\");\r\n        \r\n        //s1选择了c1和c2\r\n        s1.getCourses().add(c1);\r\n        s1.getCourses().add(c2);\r\n        \r\n        //s2选择了c2 c3\r\n        s2.getCourses().add(c2);\r\n        s2.getCourses().add(c3);\r\n        \r\n        //c1被s1选了\r\n        c1.getStudents().add(s1);\r\n        //c2被s1,s2选了\r\n        c2.getStudents().add(s1);\r\n        c2.getStudents().add(s2);\r\n        //c3被s2选了\r\n        c3.getStudents().add(s2);\r\n        //如果双向关联,一定要一方放弃主键维护\r\n        /*session.save(s1);\r\n        session.save(s2);*/\r\n        session.save(c1);\r\n        session.save(c2);\r\n        session.save(c3);\r\n        \r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n注意的地方:\r\n​ 如果双向关联,一定要一方放弃主键维护\r\n**3.2级联删除【了解】**\r\n\r\n - 删除Student,级联删除Course 高数\r\n\r\n```java\r\n/**\r\n    * 配置了级联删除 在Student.hbm.xml配置<set name=\"courses\" table=\"s_c_tab\"  cascade=\"delete\">\r\n     * 把id为1的学生删除,\r\n     * id为1的学生之前选过: id位1,2的课程.\r\n     * 级联删除既会删除正向多方数据库表中的记录，也会删除反向多方表中的记录和中间关系表中的记录\r\n     */\r\n    @Test\r\n    public void fun02(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        \r\n        Student student = session.get(Student.class, 1);\r\n        session.delete(student);\r\n        \r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n注意的地方:\r\n\r\n​ 非级联删除只会删除正向多方数据库表和中间关系表中的记录，不会删除反向多方表中的记录\r\n\r\n​ 级联删除既会删除正向多方数据库表中的记录，也会删除反向多方表中的记录和中间关系表中的记录\r\n\r\n​ 开发过程中用的比较少\r\n\r\n**3.3其它操作**\r\n\r\n - 某个学生退课\r\n\r\n```java\r\n/**\r\n    * 某个学生退课\r\n     * id为1的学生之前选过: id为1,2的课程.\r\n     * 现在的操作是:id为1的学生退掉ID为2的课程\r\n     */\r\n    @Test\r\n    public void fun01(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        //获得id为1的学生\r\n        Student s1 = session.get(Student.class, 1);\r\n​\r\n        //获得id为2的课程\r\n        Course c2 = session.get(Course.class, 2);\r\n        \r\n        s1.getCourses().remove(c2);\r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n\r\n - 某个学生改课\r\n\r\n```java\r\n/**\r\n    * 某个学生退课\r\n     * id为1的学生之前选过: id为1,2的课程.\r\n     * 现在的操作是:id为1的学生把id为2的课程改成id为3的课程\r\n     */\r\n    @Test\r\n    public void fun02(){\r\n        Session session = HibernateUtils.openSession();\r\n        Transaction transaction = session.beginTransaction();\r\n        //获得id为1的学生\r\n        Student s1 = session.get(Student.class, 1);\r\n        //获得id为2的课程\r\n        Course c2 = session.get(Course.class, 2);\r\n        Course c3 = session.get(Course.class, 3);\r\n        \r\n        s1.getCourses().remove(c2);\r\n        s1.getCourses().add(c3);\r\n        transaction.commit();\r\n        session.close();\r\n    }\r\n```\r\n\r\n[本文转载自：https://www.cnblogs.com/gdwkong/p/8337081.html](https://www.cnblogs.com/gdwkong/p/8337081.html)','2020-03-07 03:01:02','https://ae01.alicdn.com/kf/H29c02c64df194ea8be0ddd18377cd01eB.jpg','转载','','','\0','Hibernate—— 一对多、多对多关系','2020-03-07 03:04:27',40,64,1,'最近在学习一个项目，遇到了hibernate的一些问题，所有找了这篇博客来温习温习一下。'),
(82,'','',' ## ThinkPHP4种路由访问形式\r\n - 普通形式路由\r\n - pathinfo 形式路由‘\r\n - Rewrite 形式路由\r\n - 兼容形式路由\r\n \r\n \r\n**普通形式路由（get形式）**\r\n路由形式：http://网址/入库文件？m=分组名&c=控制器名&a=方法名&参数名=参数值\r\n例如：访问Home分组下的User控制器中的test方法，并且传递一个参数，id=100\r\nhttp://localhost/index.php?m=Home&c=User&a=test&id=100\r\n\r\n## 这种路由形式**不安全**\r\n\r\n**pathinfo路由形式**\r\n路由形式：http://网址/入库文件/分组名/控制器名/方法名/参数名1/参数值1/参数名2/参数值2\r\n例如：访问Home分组下的User控制器中的test方法，并且传递一个参数，id=100\r\nhttp://localhost/index.php/Home/User/test/id/100\r\n\r\n**rewrite路由形式**\r\n路由形式：http://网址/分组名/控制器名/方法名/参数名1/参数值1/参数名2/参数值2\r\n例如：访问Home分组下的User控制器中的test方法，并且传递一个参数，id=100\r\nhttp://localhost/Home/User/test/id/100\r\n\r\n***注意：该路由不能直接使用，要配置之后才能使用***\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310201954298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDI5MDA3NA==,size_16,color_FFFFFF,t_70)\r\n\r\n**兼容形式路由**\r\n路由形式：http://网址/入库文件？s=/分组名/控制器名/方法名/参数名1/参数值1\r\n***问题：兼容路由形式有几个参数？\r\n答：上述路由形式只有一个参数，参数名是s，等于后面的都是s参数的值***\r\n例如：访问Home分组下的User控制器中的test方法，并且传递一个参数，id=100\r\nhttp://localhost/index.php?s=/Home/User/test/id/100','2020-03-10 06:13:37','https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=290776095,2223161742&fm=26&gp=0.jpg','原创','','','','ThinkPHP4种路由访问形式','2020-03-10 12:23:13',38,64,76,'ThinkPHP4种路由访问形式，路由老是忘记，快来看看吧！');

/*Table structure for table `t_blog_tags` */

DROP TABLE IF EXISTS `t_blog_tags`;

CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`),
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`),
  CONSTRAINT `FK5feau0gb4lq47fdb03uboswm8` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`),
  CONSTRAINT `FKh4pacwjwofrugxa9hpwaxg6mr` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_blog_tags` */

insert  into `t_blog_tags`(`blogs_id`,`tags_id`) values 
(39,10),
(39,25),
(39,28),
(21,10),
(21,26),
(67,26),
(72,10),
(72,26),
(82,65);

/*Table structure for table `t_comment` */

DROP TABLE IF EXISTS `t_comment`;

CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`),
  KEY `FK4jj284r3pb7japogvo6h72q95` (`parent_comment_id`),
  CONSTRAINT `FK4jj284r3pb7japogvo6h72q95` FOREIGN KEY (`parent_comment_id`) REFERENCES `t_comment` (`id`),
  CONSTRAINT `FKke3uogd04j4jx316m1p51e05u` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_comment` */

insert  into `t_comment`(`id`,`avatar`,`content`,`create_time`,`email`,`nickname`,`blog_id`,`parent_comment_id`,`admin_comment`) values 
(30,'/images/avatar.png','评论测试功能','2020-03-04 03:06:18','785852255@qq.com','小金',21,NULL,'\0'),
(32,'/images/avatar.png','哈哈哈哈','2020-03-04 04:42:47','11111111@qq.com','小绿',21,NULL,'\0'),
(33,'/images/avatar.png','啊啊啊啊','2020-03-04 04:43:02','11111111@qq.com','小红',21,32,'\0'),
(34,'/images/avatar.png','你个煞笔','2020-03-04 04:43:14','11111111@qq.com','小明',21,33,'\0'),
(35,'/images/avatar.png','我是什么','2020-03-04 04:45:43','1063420620@qq.com','xiaojin',21,NULL,'\0'),
(36,'/images/avatar.png','我是','2020-03-04 04:45:51','1063420620@qq.com','小金',21,NULL,'\0'),
(37,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583228641449&di=faeb377a13d38651843585050bdf7be0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201511%2F21%2F20151121171107_zMZcy.thumb.700_0.jpeg','我是谁','2020-03-04 04:49:20','1063420620@qq.com','小金',21,NULL,''),
(38,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583228641449&di=faeb377a13d38651843585050bdf7be0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201511%2F21%2F20151121171107_zMZcy.thumb.700_0.jpeg','你是傻X','2020-03-04 04:49:54','1063420620@qq.com','xiaojin',21,37,''),
(68,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583228641449&di=faeb377a13d38651843585050bdf7be0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201511%2F21%2F20151121171107_zMZcy.thumb.700_0.jpeg','赞！！！','2020-03-05 17:15:32','11111111@qq.com','小明',67,NULL,''),
(69,'/images/avatar.jpg','这个写得不错哦','2020-03-05 17:18:10','1063420620@qq.com','1063420620',67,NULL,'\0'),
(73,'/images/avatar.jpg','喜欢，请博主继续更新！！','2020-03-07 10:06:42','110110110@qq.com','钢铁侠',39,NULL,'\0'),
(84,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583228641449&di=faeb377a13d38651843585050bdf7be0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201511%2F21%2F20151121171107_zMZcy.thumb.700_0.jpeg','还不错','2020-03-11 06:44:00','1063420620@qq.com','小金',82,NULL,''),
(85,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583228641449&di=faeb377a13d38651843585050bdf7be0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201511%2F21%2F20151121171107_zMZcy.thumb.700_0.jpeg','画虎画','2020-03-11 06:50:05','1063420620@qq.com','小',82,NULL,'');

/*Table structure for table `t_tag` */

DROP TABLE IF EXISTS `t_tag`;

CREATE TABLE `t_tag` (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_tag` */

insert  into `t_tag`(`id`,`name`) values 
(10,'Java'),
(25,'Spring'),
(26,'Hibernate'),
(27,'Mybatis'),
(28,'Springmvc'),
(29,'Struct2'),
(65,'PHP'),
(66,'HTML');

/*Table structure for table `t_type` */

DROP TABLE IF EXISTS `t_type`;

CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_type` */

insert  into `t_type`(`id`,`name`) values 
(2,'认识提升'),
(3,'错误日志'),
(4,'方法技巧'),
(63,'日常生活'),
(64,'学习笔记');

/*Table structure for table `t_user` */

DROP TABLE IF EXISTS `t_user`;

CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_user` */

insert  into `t_user`(`id`,`avatar`,`create_time`,`email`,`nickname`,`password`,`type`,`update_time`,`username`) values 
(1,'https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583228641449&di=faeb377a13d38651843585050bdf7be0&imgtype=0&src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201511%2F21%2F20151121171107_zMZcy.thumb.700_0.jpeg','2020-02-28 12:52:03','1063420620@qq.com','小金','e10adc3949ba59abbe56e057f20f883e',1,'2020-02-28 12:52:39','xiaojin'),
(76,'https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2793318718,1090947436&fm=26&gp=0.jpg','2020-03-08 03:38:17','11111111@qq.com','元哥','e10adc3949ba59abbe56e057f20f883e',2,'2020-03-08 03:38:17','yuan');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
